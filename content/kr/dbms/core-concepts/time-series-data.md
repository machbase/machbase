---
type: docs
title: '시계열 데이터 이해하기'
weight: 10
---

시계열 데이터를 고유하게 만드는 요소와 Machbase가 이를 효율적으로 처리하도록 특별히 설계된 이유를 배웁니다. 이 가이드는 시계열 데이터베이스의 기본 개념을 설명합니다.

## 시계열 데이터란 무엇인가요?

시계열 데이터는 시간으로 인덱싱된 데이터 포인트의 시퀀스입니다. 각 레코드는 타임스탬프와 하나 이상의 값을 가집니다:

```
(타임스탬프, 값1, 값2, ...)
```

### 일반적인 예시

**IoT 및 센서**:
- 매초 온도 측정값
- 차량의 GPS 좌표
- 스마트 미터 전력 사용량
- 제조 장비 원격 측정

**애플리케이션 모니터링**:
- 서버 CPU/메모리 메트릭
- 애플리케이션 로그
- HTTP 요청 로그
- 데이터베이스 쿼리 성능

**비즈니스 데이터**:
- 주식 시장 틱
- 판매 거래
- 웹사이트 클릭스트림
- 모바일 앱 이벤트

## 시계열 워크로드의 특성

### 1. 쓰기 중심

시계열 시스템은 쓰기가 지배적입니다:
- **초당 수백만 건의 쓰기** (센서, 로그, 이벤트)
- **적은 업데이트 또는 삭제** (과거 데이터는 거의 변경되지 않음)
- **추가 전용 패턴** (항상 새 데이터 추가)

전통적인 데이터베이스가 어려운 이유:
- 행 레벨 잠금이 쓰기 속도를 늦춤
- 복잡한 UPDATE 로직이 불필요함
- 트랜잭션 오버헤드 낭비

**Machbase 솔루션**: 행 잠금이 없는 추가 전용 아키텍처.

### 2. 시간 기반 쿼리

대부분의 쿼리는 시간 범위를 포함합니다:

```sql
-- 지난 1시간의 데이터
SELECT * FROM logs DURATION 1 HOUR;

-- 어제 통계
SELECT AVG(temperature) FROM sensors
WHERE time BETWEEN '2025-10-09 00:00:00' AND '2025-10-10 00:00:00';
```

전통적인 데이터베이스가 어려운 이유:
- 시간에 최적화되지 않은 일반 인덱스
- 시간 범위에 대한 전체 테이블 스캔
- 시간 인식 파티셔닝 없음

**Machbase 솔루션**: 시간 기반 파티셔닝 및 인덱싱 내장.

### 3. 최근 데이터 중심

사용자는 최근 데이터에 가장 관심이 많습니다:
- 모니터링을 위한 최근 24시간
- 트렌드 분석을 위한 지난 주
- 규정 준수/아카이브를 위한 오래된 데이터

전통적인 데이터베이스가 어려운 이유:
- 모든 데이터를 동등하게 처리
- 자동 에이징 정책 없음
- 수동 아카이빙 프로세스

**Machbase 솔루션**: DURATION 키워드, 자동 파티셔닝, 효율적인 시간 기반 삭제.

### 4. 높은 압축 가능성

시계열 데이터는 매우 잘 압축됩니다:
- 순차적 타임스탬프
- 반복되는 패턴
- 유사한 값

전통적인 데이터베이스가 어려운 이유:
- 행 지향 스토리지
- 일반 압축
- 2-5배 압축이 일반적

**Machbase 솔루션**: 특수 압축을 사용한 컬럼형 스토리지 (10-100배 비율).

### 5. 대량 집계

일반적인 분석 쿼리:
- 시간 창에 대한 MIN, MAX, AVG
- 시간 간격별 그룹화
- 통계 요약

전통적인 데이터베이스가 어려운 이유:
- 온디맨드로 집계 계산
- 사전 계산된 통계 없음
- 대규모 데이터 세트에 대해 느림

**Machbase 솔루션**: 사전 계산된 통계를 가진 자동 Rollup 테이블.

## 전통적인 데이터베이스가 실패하는 이유

### 문제 1: 행 지향 스토리지

전통적인 데이터베이스는 전체 행을 함께 저장합니다:

```
행 1: [timestamp1, sensor_id, temp, humidity]
행 2: [timestamp2, sensor_id, temp, humidity]
행 3: [timestamp3, sensor_id, temp, humidity]
```

**문제**: "AVG(temperature)"를 쿼리하면 데이터베이스가 temperature만이 아닌 모든 컬럼을 읽습니다.

**Machbase 접근 방식**: 컬럼형 스토리지는 필요한 컬럼만 읽습니다.

### 문제 2: B-Tree 인덱스

전통적인 데이터베이스는 B-Tree 인덱스를 사용합니다:
- 랜덤 액세스에 좋음
- 순차 쓰기에 비용이 많이 듦
- 시간 순서 데이터에 최적화되지 않음

**Machbase 접근 방식**: LSM 인덱스 및 시간 기반 파티셔닝.

### 문제 3: ACID 오버헤드

전통적인 데이터베이스는 완전한 ACID 보장을 제공합니다:
- 행 레벨 잠금
- 트랜잭션 로그
- 롤백 지원

**시계열에 불필요**:
- 과거 데이터는 절대 변경되지 않음
- 동일한 행에 대한 동시 업데이트 없음
- 오버헤드 낭비

**Machbase 접근 방식**: 추가 전용 데이터를 위한 단순화된 아키텍처.

### 문제 4: 시간 인식 없음

전통적인 데이터베이스는 시간을 이해하지 못합니다:
- 자동 시간 기반 파티셔닝 없음
- 내장된 보존 정책 없음
- 시간 최적화 쿼리 없음

**Machbase 접근 방식**: 시간은 일급 개념입니다.

## Machbase 설계 원칙

### 1. 추가 전용 아키텍처

데이터는 추가만 되고 수정되지 않습니다:

```sql
-- 허용: 새 데이터 추가
INSERT INTO sensors VALUES ('sensor01', NOW, 25.3);

-- Tag/Log 테이블에서 허용되지 않음: 오래된 데이터 수정
UPDATE sensors SET temperature = 26.0 WHERE id = 123;  -- ✗
```

**이점**:
- 행 잠금 없음
- 초고속 쓰기 (초당 수백만 건)
- 데이터 무결성 (과거를 변경할 수 없음)

### 2. 시간 기반 파티셔닝

데이터는 자동으로 시간별로 파티션됩니다:

```
파티션 1: 2025-10-01 ~ 2025-10-07
파티션 2: 2025-10-08 ~ 2025-10-14
파티션 3: 2025-10-15 ~ 2025-10-21
```

**이점**:
- 쿼리는 관련 파티션만 스캔
- 쉬운 데이터 보존 (오래된 파티션 삭제)
- 파티션당 최적 압축

### 3. 컬럼형 압축

각 컬럼은 별도로 저장됩니다:

```
타임스탬프:    [100, 101, 102, 103, 104, ...]
센서 ID:      [s01, s01, s01, s02, s02, ...]
온도:         [22.5, 22.7, 22.6, 21.3, 21.5, ...]
```

**이점**:
- 높은 압축 (유사한 값)
- 필요한 컬럼만 읽기
- 더 빠른 분석 쿼리

### 4. 쓰기 최적화 인덱스

LSM (Log-Structured Merge) 인덱스:
- 순차 쓰기에 최적화
- 메모리로 배치 쓰기
- 주기적으로 디스크로 병합

**이점**:
- 초당 수백만 건의 쓰기
- 쓰기 증폭 없음
- 일관된 성능

### 5. 자동 통계 (Rollup)

Tag 테이블은 자동으로 통계를 생성합니다:

```sql
-- 원시 데이터: 수백만 행
INSERT INTO sensors VALUES ('sensor01', NOW, 25.3);

-- 자동 Rollup: 초당, 분당, 시간당
SELECT * FROM sensors WHERE rollup = hour;
-- 반환: MIN, MAX, AVG, SUM, COUNT, SUMSQ
```

**이점**:
- 즉각적인 분석
- 수동 집계 없음
- 쿼리 시간 단축

## 시계열 vs 전통적인 데이터베이스

| 기능 | 전통적인 DB | Machbase |
|---------|---------------|----------|
| **주요 용도** | 트랜잭션 | 분석 |
| **쓰기 패턴** | 랜덤 | 순차 |
| **UPDATE 지원** | 완전 | 제한적 |
| **인덱싱** | B-Tree | LSM + 파티션 |
| **스토리지** | 행 지향 | 컬럼형 |
| **압축** | 2-5배 | 10-100배 |
| **쓰기 속도** | 초당 수천 건 | 초당 수백만 건 |
| **시간 쿼리** | 일반 | 최적화 |
| **데이터 보존** | 수동 | 자동 |

## 시계열 데이터 패턴

### 패턴 1: 고주파 센서

```
센서 ID: sensor01
주파수: 초당 10회 측정
데이터 볼륨: 일일 864,000회 측정
```

**최적**: SUMMARIZED 컬럼을 가진 Tag 테이블

```sql
CREATE TAGDATA TABLE sensors (
    sensor_id VARCHAR(20) PRIMARY KEY,
    time DATETIME BASETIME,
    value DOUBLE SUMMARIZED
);
```

### 패턴 2: 이벤트 스트림

```
유형: 애플리케이션 로그
주파수: 가변 (버스트)
데이터 볼륨: 일일 수백만 건
스키마: 유연 (많은 컬럼)
```

**최적**: Log 테이블

```sql
CREATE TABLE app_logs (
    level VARCHAR(10),
    message VARCHAR(2000),
    user_id INTEGER
);
```

### 패턴 3: 실시간 상태

```
유형: 라이브 대시보드 데이터
주파수: 지속적인 업데이트
데이터 볼륨: 소량 (수백 행)
지속성: 불필요
```

**최적**: Volatile 테이블

```sql
CREATE VOLATILE TABLE live_status (
    device_id INTEGER PRIMARY KEY,
    status VARCHAR(20),
    last_updated DATETIME
);
```

### 패턴 4: 차원 데이터

```
유형: 장치 메타데이터
주파수: 드문 업데이트
데이터 볼륨: 소량 (수천 행)
지속성: 필요
```

**최적**: Lookup 테이블

```sql
CREATE LOOKUP TABLE devices (
    device_id INTEGER,
    name VARCHAR(100),
    location VARCHAR(200)
);
```

## 일반적인 시계열 과제

### 과제 1: 데이터 볼륨

**문제**: 센서가 일일 수백만 건의 측정값을 생성

**Machbase 솔루션**:
- 고속 수집 (APPEND 프로토콜)
- 자동 압축 (10-100배)
- 시간 기반 보존

```sql
-- 30일만 유지
DELETE FROM sensors EXCEPT 30 DAYS;
```

### 과제 2: 쿼리 성능

**문제**: 수백만 행 분석이 느림

**Machbase 솔루션**:
- 자동 Rollup 통계
- 시간 기반 파티셔닝
- 컬럼형 스토리지

```sql
-- 빠름: 사전 집계된 데이터 쿼리
SELECT * FROM sensors WHERE rollup = hour;
```

### 과제 3: 늦게 도착하는 데이터

**문제**: 데이터가 순서 없이 도착

**Machbase 솔루션**:
- LSM 인덱스가 순서 없는 쓰기 처리
- 백그라운드 병합 프로세스
- 일관된 쿼리 결과

### 과제 4: 여러 시간대

**문제**: 다양한 시간대를 가진 글로벌 배포

**Machbase 솔루션**:
- UTC로 저장, 로컬 시간으로 표시
- 시간대 변환 함수
- 클라이언트 측 시간대 설정

```bash
machsql -z +0900  # 한국 시간대
```

## 모범 사례

### 1. 적절한 테이블 타입 사용

데이터 특성을 테이블 타입에 맞춥니다:
- 정규 센서 측정값 → Tag 테이블
- 가변 이벤트 스트림 → Log 테이블
- 실시간 업데이트 → Volatile 테이블
- 참조 데이터 → Lookup 테이블

### 2. 데이터 보존 구현

데이터를 영원히 보관하지 마세요:

```sql
-- 일일 정리 작업
DELETE FROM logs EXCEPT 90 DAYS;
```

### 3. 시간 쿼리에 DURATION 사용

시간 범위에 최적화된 구문:

```sql
-- 좋음
SELECT * FROM logs DURATION 1 HOUR;

-- 덜 최적
SELECT * FROM logs WHERE _arrival_time >= NOW - INTERVAL '1' HOUR;
```

### 4. 가능하면 배치 쓰기

대량 삽입에 APPEND 프로토콜 사용:
- 더 높은 처리량
- 더 나은 압축
- 오버헤드 감소

### 5. 원시 데이터가 아닌 Rollup 쿼리

분석의 경우 사전 집계된 데이터 사용:

```sql
-- 빠름: Rollup
SELECT AVG(avg_temperature) FROM sensors WHERE rollup = hour;

-- 느림: 원시 데이터
SELECT AVG(temperature) FROM sensors;
```

## 다음 단계

이제 시계열 데이터를 이해했으니:

1. **읽기**: [테이블 타입 개요](../table-types-overview/) - 올바른 테이블 선택
2. **학습**: [인덱싱 및 성능](../indexing/) - 쿼리 최적화
3. **실습**: [튜토리얼](../../tutorials/) - 실습 연습

## 핵심 요점

1. 시계열 데이터는 **쓰기 중심**이고 **시간 중심**입니다
2. 전통적인 데이터베이스는 시계열에 **최적화되지 않음**
3. Machbase는 **추가 전용** 아키텍처 사용
4. **컬럼형 스토리지**로 높은 압축 가능
5. **시간 기반 파티셔닝**으로 쿼리 최적화
6. **자동 Rollup**으로 즉각적인 분석 제공
7. 데이터 패턴에 맞는 **올바른 테이블 타입** 선택

---

시계열 데이터 기초를 이해하면 더 나은 Machbase 솔루션을 설계하는 데 도움이 됩니다!
