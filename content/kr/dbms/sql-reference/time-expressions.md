---
title: '상대 시간 표현'
type: docs
weight: 75
---

## 개요

상대 시간 표현은 알려진 기준 시점으로부터의 차이를 SQL 문 안에서 직접 기술할 수 있도록 해 줍니다. 최근 계측 데이터를 필터링하거나 향후 작업을 예약하고, 보조 함수 호출 없이 시계열 윈도를 정렬해야 하는 운영자에게 유용합니다.

> **참고**: 이 기능은 Machbase 8.0.50 이상에서 지원됩니다.

## 빠르게 살펴보기

1. 최근 1시간 데이터를 조회합니다.
   ```sql
   SELECT * FROM sensor_log WHERE event_time > now - 1h;
   ```
2. 2일 6시간 이후까지의 일정을 확인합니다.
   ```sql
   SELECT * FROM maintenance_plan WHERE planned_at < now + 2d6h;
   ```
3. 하위 초 단위까지 세그먼트를 결합합니다.
   ```sql
   SELECT to_char(now + 3s125ms10us4ns, 'YYYY-MM-DD HH24:MI:SS mmm:uuu:nnn');
   ```

## 구문 요약

- 리터럴은 공백 없이 이어지는 `<숫자><단위>` 세그먼트 하나 이상으로 작성합니다.
- 단위는 소문자를 사용하며, 서로 다른 크기는 이어 붙여 표현합니다(`2h30m`).
- `+` 또는 `-` 접두어를 붙이거나 산술식을 사용할 수 있습니다(`now - 90m`, `sample_time + 15s` 등).
- 숫자 뒤에 단위를 붙이지 않으면 나노초 단위로 해석됩니다.
- 상대 리터럴은 `INTERVAL`로 평가되며, `DATETIME`에 더하거나 빼면 결과 역시 `DATETIME`이 됩니다.

## 지원 단위

| 접미사 | 의미             | 예시     | 동일한 기간             |
|--------|------------------|---------|---------------------|
| `ns`   | 나노초           | `500ns` | 500 나노초            |
| `us`   | 마이크로초       | `20us`  | 0.00002초           |
| `ms`   | 밀리초           | `15ms`  | 0.015초             |
| `s`    | 초               | `45s`   | 45초                |
| `m`    | 분               | `30m`   | 30분                |
| `h`    | 시간             | `12h`   | 12시간              |
| `d`    | 일               | `7d`    | 7일                 |
| `w`    | 주               | `2w`    | 14일                |

> **참고**: 월과 연은 길이가 일정하지 않아 지원하지 않습니다. 지원하지 않는 접미사(`1y`, `1mo` 등)를 사용하면 `ERR_QP_TIME_FORMAT` 오류가 발생합니다.

## 복합 리터럴 작성

- 가독성을 위해 가장 큰 단위부터 작성합니다(`5d4h30m`).
- 값이 0인 세그먼트는 생략합니다. `4h15m0s`보다는 `4h15m`이 좋습니다.
- 세그먼트 순서는 바뀌어도 되지만 일관성을 유지하면 실수를 줄일 수 있습니다. `1h30m`과 `30m1h`는 동일하게 평가됩니다.
- 긴 간격은 SQL 문자열 리터럴에서 밑줄로 구분할 수 없으므로 주석(`/* +1d12h30m */`)을 달거나 SQL 변수에 저장해 문서화하는 방식을 권장합니다.

## 활용 패턴

### 시간 구간 필터링

```sql
-- 최근 24시간 기록
SELECT *
  FROM rtrollup
 WHERE time BETWEEN now - 1d AND now;

-- 최근 10분 이내 발생한 알람
SELECT alert_id, level, occurred_at
  FROM alert_log
 WHERE occurred_at >= sysdate - 10m;
```

### 향후 작업 예약

```sql
-- 다음 영업일 + 2시간 이내 실행할 작업
SELECT job_id, scheduled_at
  FROM job_queue
 WHERE scheduled_at <= now + 1d2h;

-- 30분 후에 예정된 정비 일정을 등록
INSERT INTO device_schedule (device_id, maintenance_due)
VALUES ('device-001', now + 30m);
```

### 시간 기반 필터와 조인

```sql
-- 특정 시간 범위의 데이터 선택
SELECT device_id, ts, value
  FROM metrics_stream
 WHERE ts BETWEEN now - 15m AND now
   AND device_id = 'sensor-01';

-- 상대 오프셋을 이용해 두 소스를 조인
SELECT a.ts, a.value AS raw_value, b.value AS calibrated
  FROM raw_metrics a
  JOIN calibration b
    ON b.ts BETWEEN a.ts - 500ms AND a.ts + 500ms;
```

### 문자열 리터럴과 캐스팅

```sql
SELECT to_char('2024-05-01' + 3d, 'YYYY-MM-DD');           -- 2024-05-04
SELECT to_char('2024-05-01 08:00:00' - 4h15m,
               'YYYY-MM-DD HH24:MI:SS');                   -- 2024-05-01 03:45:00
SELECT to_char('2024-05-01'::datetime + 2h30m45s250ms,
               'YYYY-MM-DD HH24:MI:SS mmm');               -- 2024-05-01 02:30:45 250
```

### 순수 숫자와 혼합

```sql
-- 숫자 리터럴은 기본적으로 나노초이므로 정확히 1초가 더해집니다.
SELECT event_time + 1000000000 AS event_time_plus_1s
  FROM events;

-- 250나노초를 뺍니다.
SELECT event_time - 250 AS event_time_minus_250ns
  FROM events;
```

## 동작 및 제한 사항

- 정밀도는 나노초까지 지원합니다. 64비트 범위를 넘으면 오버플로가 발생합니다.
- 산술 연산은 일반 우선순위를 따릅니다. 괄호 → 곱셈/나눗셈 → 덧셈/뺄셈 순이며, 연산이 길어질 때는 괄호를 사용하세요.
- 인터벌 비교는 최종 `DATETIME` 값을 기준으로 이루어집니다. 인터벌 자체는 `ORDER BY` 절에서 사용할 수 없습니다.
- 이 기능은 스탠더드 에디션에서 제공되며, 구버전 지원 여부는 릴리스 노트를 확인하십시오.

## 오류 처리

| 시나리오                                | 오류 코드                 | 해결 방법                                     |
|----------------------------------------|---------------------------|----------------------------------------------|
| 지원하지 않는 접미사(`1y`, `5mo`)      | `ERR_QP_TIME_FORMAT`      | 지원 단위(`30d` 등)로 교체합니다.             |
| 단위 누락(`now + 10`)                   | 나노초로 해석됨            | 분/초 등을 의도했다면 명시적으로 접미사를 붙입니다. |
| 값이 너무 큰 리터럴(`1000000d`)        | `ERR_OVERFLOW_INTERVAL`   | 크기를 줄이거나 반복 처리로 로직을 나눕니다. |
| 숫자가 아닌 문자가 포함됨(`1h3xm`)     | `ERR_QP_TIME_FORMAT`      | 오탈자를 수정합니다(`1h3m`).                  |

## 모범 사례

- 팀 전체가 소문자 접미사를 사용하도록 표준화하세요.
- 자주 쓰는 오프셋은 구성 테이블에 저장해 재사용과 감사에 활용합니다.
- 복잡한 표현식에는 유지보수를 돕는 주석을 남깁니다(`-- subtract 1 business week`).
- 리터럴을 동적으로 생성할 때는 잘못된 접미사가 주입되지 않도록 입력 값을 검증합니다.

## 문제 해결 체크리스트

- **예상과 다른 범위**: `now`와 계산된 경계를 함께 출력해 오프셋을 검증합니다.
- **잘못된 단위**: 숫자만 입력하면 나노초로 처리된다는 점을 기억하고, 사람이 읽기 쉬운 단위가 필요하면 `s`, `m`, `h` 등을 붙입니다.
- **함수와의 조합**: 윈도 함수나 집계 필터와 함께 사용할 때는 서브쿼리에서 리터럴을 평가해 문장당 한 번만 계산되도록 합니다.

## 자주 묻는 질문

- **`ADD_TIME`과 함께 사용할 수 있나요?** 가능합니다. `ADD_TIME(now, '0/0/0 0:15:0') + 30s`처럼 함수와 리터럴을 연결할 수 있습니다.
- **리터럴을 변수에 저장할 수 있나요?** 상대 시간 리터럴은 쿼리 실행 시 평가되므로 변수에 저장할 수 없습니다. 대신 반복해서 사용할 쿼리에 직접 포함시키세요.
- **영업일 기준으로 계산하려면?** 상대 리터럴은 절대 시간 간격만 처리합니다. 영업일 계산은 애플리케이션 로직이나 캘린더 테이블을 활용하세요.

## 참고 치트시트

```
패턴             의미
--------------  --------------------------------------------
now - 5m        정확히 5분 전 시각
sysdate + 1d    시스템 시간 기준 24시간 후(내일)
col_ts + 90s    컬럼 값을 90초 뒤로 이동
'2024-01-01' + 2w  리터럴 날짜에 14일을 더함
value + 250     `value`에 250나노초를 더함
```

상대 시간 표현은 보조 함수 없이도 정밀하고 읽기 쉬운 시간 연산을 제공합니다. `WHERE` 절, 계산 컬럼, Projection, 프로시저 코드 등 표현식을 사용할 수 있는 어디에서나 활용해 Machbase 분석을 간결하고 유지보수하기 쉽게 만드세요.
