---
title: MAP Functions
type: docs
weight: 31
---

*MAP* functions are the core of the transforming data.


## TAKE()

![map_take](../img/map_take.jpg)

*Syntax*: `TAKE( n )`

Takes first *n* records and stop the stream.

- `n` `number` specify how may records to be taken.

## DROP()

![map_drop](../img/map_drop.jpg)

*Syntax*: `DROP( n )`

Ignore first *n* records, it simply drops the *n* records.

- `n` `number` specify how may records to be dropped.

## MAPKEY()

![map_mapkey](../img/map_mapkey.jpg)

*Syntax*: `MAPKEY( newkey )`

Replace current key value with the given newkey.

## PUSHKEY()

![map_pushkey](../img/map_pushkey.jpg)

*Syntax*: `PUSHKEY( newkey )`

Apply new key on each record. The orignal key is push into value tuple.

For example, if an original record was `{key: 'k1', value: [v1, v2]}` and applied `PUSHKEY(newkey)`, it produces the updated record as `{key: newkey, values: [k1, v1, v1]}`.

## POPKEY()

![map_popkey](../img/map_popkey.jpg)

*Syntax*: `POPKEY( [idx] )`

Drop current key of the record, then promote *idx*th element of *tuple* as a new key.

For example, if an original record was `{key: k, value: [v1, v2, v3]}` and applied `POPKEY(1)`, it produces the updated record as `{key: v2, value:[v1, v3]}`.

if use `POPKEY()` without argument it is equivalent with `POPKEY(0)` which is promoting the first element of the value tuple as the key.

## GROUPBYKEY()

![map_popkey](../img/map_groupbykey.jpg)

*Syntax*: `GROUPBYKEY( [lazy(boolean)] )`

- `lazy(boolean)` If it set `false` which is default *GROUPBYKEY()* yields new grouped record when the key of incoming record has changed from previous record. If it set `true`, *GROUPBYKEY()* waits the end of the input stream before yield any record. 

Takes multiple continuous records that have same key, then produces a new record which have value array contains all individual values.

For example, if an original records was `{key:k, value:[v1, v2]}`, `{key:k, value:{v3, v4}}`...`{key:k, value:{vx, vy}}`, it produces the new record as `{key:k, value:[[v1,v2],[v3,v4],...,[vx,vy]]}`.

The *GROUPBYKEY()* works comparing the key of current record to previous one, if it found the key has been changed, then produces new record. As result it can makes a group only if the continuous records have same key.

## FLATTEN()

![map_flatten](../img/map_flatten.jpg)

*Syntax*: `FLATTEN()`

It works the oposite way of *GROUPBYKEY()*. Take a record whose value is multi-dimension tuple, produces multiple records for each elements of the tuple reducing the dimension.

For example, if an original record was `{key:k, value:[[v1,v2],[v3,v4],...,[vx,vy]]}`, it produces the new multiple records as `{key:k, value:[v1, v2]}`, `{key:k, value:{v3, v4}}`...`{key:k, value:{vx, vy}}`.

## PUSHVALUE()

*Syntax*: `PUSHVALUE( idx, value [, name] )`

- `idx` *int* Index where newValue insert at. (0 based)
- `value` *expression* New value
- `name` *string* column's name (default 'column')

Insert the given value into the current values.

## POPVALUE()

*Syntax*: `PUSHVALUE( idx [, idx2, idx3, ...] )`

- `idx` *int* array of indexes that will removed from values

It removes elements that specified by `idx`es from value array.

## MAPVALUE()

![map_mapvalue](../img/map_mapvalue.jpg)

*Syntax*: `MAPVALUE( idx, newValue [, newName] )`

- `idx` *int*  Index of the value tuple. (0 based)
- `newValue` *expression* New value
- `newName` *string* change column's name with given string

Replace the value of the element at the given index. For examaple, `MAPVALUE(0, value(0)*10)` replaces a new value that is 10 times of the first element of value tuple.

If the `idx` is out of range, it will work as `PUSHVALUE()` does. `MAPVALUE(-1, value(1)+'_suffix')` inserts a new string value that concatenates '_suffix' with the 2nd element of value.

## FILTER()

![map_filter](../img/map_filter.jpg)

*Syntax*: `FILTER( condition )`

Apply the condition statement on the incoming record, then it pass the record only if the *condition* is *true*.

For example, if an original record was `{key: k1, value[v1, v2]}` and apply `FILTER(count(V) > 2)`, it simply drop the record. If the codition was `FILTER(count(V) >= 2)`, it pass the record to the next function.

## TIMEWINDOW()

*Synatax*: `TIMEWINDOW( fromTime, untilTime, period, fields...)`

Aggregate raw values between fromTime and untilTime into a periodic duration and fill zero value if any value exists for the period.

- `fromTime` *time* from (inclusive)
- `untilTime` *time* until (exclusive)
- `period` *duration*
- `fields` *string* specifies each field's aggration function and indicates which column is the time. It should be one of `time`, `avg`, `sum`, `first`, `last`, `min`, `max`.

```js
SQL(`
    select
        time, value
    from EXAMPLE
    where
        name = 'temperature'
    and time between 
            1700022915492366000
        and 1700022922562366000`)
TIMEWINDOW(
    time(1700022913 * 1000000000),
    time(1700022925 * 1000000000),
    period('1s'),
    'time',
    'avg'
)
CSV()
```

## FFT()

![map_fft](../img/map_fft.jpg)

*Syntax*: `FFT()`

It assumes value of the incoming record is an array of *time,amplitude* tuples, then applies *Fast Fourier Transform* on the array and replaces the value with an array of *frequency,amplitude* tuples. The key remains same.

For example, if the incoming record was `{key: k, value[ [t1,a1],[t2,a2],...[tn,an] ]}`, it transforms the value to `{key:k, value[ [F1,A1], [F2,A2],...[Fm,Am] ]}`.

## SCRIPT()

*Syntax*: `SCRIPT({ ... script code... })`

Supporting script language.

1. **tengo**
 [tengo](https://github.com/d5/tengo) is a Golang like script.
 The additional package "context" package is available that is exposing the TQL specific functionalities
 based the default packages from tengo.

![map_script](../img/map_script.jpg)